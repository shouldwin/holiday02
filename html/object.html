<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
    <script>
        /*对象直接量*/
        var empty ={};
        var point = {x:0,y:0};
        var point2 = {x:point.x,y:point.y+1};
        var book = {
            "main title" : "Javascript",
            'sub-title' : "the defined guide",         //属性名中可以有连字符，空格；必须用字符串表示
            "for" : "all adudiences",                  //for为保留字。所以必须用引号
            author:{                                //属性名为一个对象
                firstname : "David",
                surname :　"Flanagan"            //5中，对象直接量中的最后一个属性后的逗号将忽略
            }
        };

        /* new */
        var o = new Object();
        var d = new Date();

        /* create */
        var o1 = Object.create({x:1,y:1});      // o1继承了属性x，y
        var o2 = Object.create(null);           //o2不继承任何属性和方法
        var o3 = Object.create(Object.prototype);   //此种方法和{}和new Object（）一样

        /* 通过原型继承创建一个新对象 */
        function inherit(p){        //inherit可以防止对对象的意外修改，不能传入null，不能用第二可选参数
            if(p == null) throw TypeError();        //p不能为null
            if(Object.create)                       //如果有create属性直接使用
                return Object.create(p);

                var t = typeof p;                   //如果没有，进行下一步检测
                if(t !=="object" && t !== "function")  throw TypeError();
                function f(){};             //定义一个空构造函数，将其原型属性设置为p，使用f（）创建p的继承对象
                f.prototype = p;
                return new f();
        }

        /* for/in 遍历关联数组 */
        function getvalue(portfolio){
            var total = 0.0;
            for(stock in portfolio){
                var shares = portfolio[stock];      //得到每只股票的份额
                var price = getquote(stock);        //查找股票价格
                total += shares*price;
            }
            return total;
        }

        /* 继承 */
        var o ={};
        o.x = 1;
        var p = inherit(o);
        p.y = 2;
        var q = inherit(p);
        q.z = 3;
        var s = q.toString();
        q.x + q.y ;                 //3   x y分别继承o，p

        /* 覆盖 */
        var u = {r:1};
        var c = inherit(u);
        c.x = 1;
        c.y = 2;
        c.r = 3;
        alert(u.r);       //  1  原型对象没有改变

        /* delete */
        o = {x:1};
        delete o.x;         //true  已删除x
        delete o.x;         //true  什么都没做
        delete Object.prototype;    //不能删除，属性不可配置
        var x = 1;      //全局变量
        delete this.x;          //不能删除全局变量以及全局函数

        /* in */
        var o = {x:1};
        "x" in o;       //true
        "y" in o;       //false
        "toString" in o;        //true

        /* hasOwnProperty */
        o.hasOwnProperty("x");      //true
        o.hasOwnProperty("y");      //false
        o.hasOwnProperty("toString");       //false 继承属性

        /* propertyIsEnumerable */
        var o = inherit({y:2});
        o.x = 1;
        o.propertyIsEnumerable("x");        //true     可枚举的自有属性x
        o.propertyIsEnumerable("y");        //false  y是继承来的
        Object.prototype.propertyIsEnumerable("toString");      //false  不可枚举
        /*   !==   可以区分null   undefined     */

        /* 枚举属性 for/in */
        for(p in o){        //跳过继承的属性
            if(!o.hasOwnProperty(p))
            continue;
        }
        for(p in o){        //跳过方法
            if(typeof o[p] === "function")
            continue;
        }

        /* 用来枚举属性的对象工具函数
         * 把p中的可枚举属性复制到o中，并返回o
          * 如果o和p中含有同名属性，则覆盖o中的属性
          * 这个函数并不处理getter和setter以及复制属性
          * */
        function extend(o,p){
            for(prop in p){
                o[prop] = p[prop];
            }
            return o;
        }

        /*
        * 将p中可枚举属性复制到o，并返回o
        * 如果o，p中有同名属性，o中属性不受影响
        * 这个函数并不处理getter和setter以及复制属性
        * */
        function merge(o,p){
            for(prop in p){
                if(o.hasOwnProperty[prop]) continue;    //过滤掉已经在o中存在的属性
                o[prop] = p[prop];
            }
            return o;
        }

        /*
        * 如果o中的属性在p中没有同名属性，则从o中删除这个属性，返回o
        * */
        function restrict(o,p){
            for(prop in p){
                if(!(prop in p))
                delete o[prop];
            }
            return o;
        }

        /*
         * 如果o中的属性在p中存在同名属性，则从o中删除这个属性，返回o
         * */
        function substract(o,p){
            for(prop in p){
                delete o[prop];
            }
            return o;
        }

        /* 返回一个拥有o，p属性的新对象，有重名属性使用p中的属性值*/
        function union(o,p){
            return extend(extend({},o),p);
        }

        /* 返回一个数组这个数组包含的是o中可枚举的自有属性的名字 */
        function keys(o){
            if(typeof o !== "object") throw TypeError();        //必须是对象
            var result = [];
            for(var prop in p){
                if(o.hasOwnProperty(prop))
                result.push(prop);
            }
            return result;
        }


    </script>
</body>
</html>